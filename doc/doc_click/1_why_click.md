# Why Click?

有很多库可以编写命令行应用；那么Click有什么存在的必要呢？

这个问题很容易回答：因为这不单单是一个Python的命令行工具，它还包括:

- 它是惰性可混合的(lazily composable)，在这方面没有限制
- 完全遵从Unix命令行的惯例
- 支持从环境变量中读取值
- 支持提示用户输入
- 可以完全的嵌套和混合
- 兼容Python2/3
- 支持文件处理
- 有一些有用的工具(获取终端dimensions， ANSI colors， 直接获取键盘输入，屏幕清除，查找配置路径，发布app和编辑器，等等...)

还有很多库可以代替Click，如果你喜欢的话也可以使用那些库。最出名的两个是`argparse`和`optparse`.

Click实际上是封装了`optparse`，它本身并不解析任何东西。不是基于`argparse`的原因是因为argparse本身的缺陷所以不能支持命令嵌套。

Click的设计哲学是让你开心的编码而不会让自己本身变为你的负担。它不是非常得弹性。举例来说，目前它还不运行你完全的自定义帮助页面。因为Click主要是为了让你嵌套命令行工具的。

太多的自定义会打乱最初的设计。

Click是为了支持Flask微框架生态而写，因为没有其它工具可以提供flask想要的功能。

想要充分立即Click，我强烈推介你阅读"Complex Applications"一章。

## Why not Argparse?

Click是基于`optparse`而不是`argparse`的。这是底层实现的东西，用户一般不需过多考虑。Click不基于`argparse`的原因是它存在一些问题导致处理某些命令行接口很难：

- `argparse`有它自己的一套规则来猜测一个参数是位置参数还是选项参数。如果一个不完整的命令它就不知道怎么办了。这和Click试图分发子解析器的目的相违背。

- `argparse`目前不支持禁用零散参数。没有这个特性就不可能实现Click的嵌套解析器。

## Why not Docopt etc.?

Docopt和其它一些工具也很酷，但是它们很少可以像click这样处理命令的嵌套以及混合。Click是Python中首个目标为创建应用的一个层级混合的库。

Docopt，通过一套规则来解析docstring。副作用是必须严格按照一套规则来编写docstring。好处是它的帮助文本更细致；不好的方面是不能重新封装输出为当前终端的宽度，并且很难继续翻译。它不能处理参数分发和callback调用。

另外，它还让混合变得很难。由于docopt不支持子命令的分发，它也不可以自动支持子命令的枚举。

Click目标是支持完全可混合的命令行接口：

- Click不只是用户解析(命令行参数)，并且会把它分发给适当的代码
- Click有调用上下文的概念，允许父命令接受子命令的数据响应
- Click对于所有参数和命令都可以获取相关信息，所以可以生成统一风格的帮助文本
- Click可以理解类型，在发生错误的时候会给用户一个错误信息。其它开发者编写的子命令也不会发出另一个风格的错误信息。
- Click对于整个程序拥有一个meta信息。

## Why Hardcoded Behaviors?

另一个问题是为什么Click使用optparse，但是有一些部分采用硬编码而没有设计为可配置形式。这有很多因素，最关键的一个是太多的配置性会导致难以维护一致性的接口。

举例来说，optparse的callback可以接受任意数量的参数。因为命令行上面存在语法歧义，其实没有办法实现完全的参数。所以需要做出一种权衡。

## Why No Auto Correction?

为什么Click不支持`optparse`和`argparse`都有的长参数自动扩展？这是因为向后兼容性方面的有问题。如果人们依赖这种自动修改的参数形式，那么之后如果再添加一些参数的话，这种习惯就会带来bug。

