官网url: [https://www.python.org/dev/peps/pep-3101/](https://www.python.org/dev/peps/pep-3101/)

[TOC]

## PEP 3103 -- Advanced String Formatting(高级字符串格式化)

-- | --
-- | --
PEP: | 3103
标题: | 高级字符串格式化
作者: | Talin <viridia at gmail.com>
状态: | Final
类型: | Standards Track
创建时间: | 2006-4-16
Python版本: | 3.0
Post-历史 | 2006-4-16,2006-5-6,2007-6-10,2007-8-14,2008-9-14

### Abstract(摘要)

这份PEP提议了一种内置字符串格式化操作的新系统，目的是要代替当前的`%`字符串格式化操作符。

### Rationale(基本原理)

Python当前提供了两种字符串插值方法:

- 字符串的`%`操作符<sup>[1]</sup>
- `string.Template`模块<sup>[2]</sup>

这个PEP提案的主要范围是提供一种内置的字符串格式化操作(也可以说是，内置`str`类型的一种方法).

`%`操作符主要受限的地方是它是一个binary(二元?)操作符，因此最多接受两个参数.其中一个参数已经献给了格式化字符串，其它所有的参数都压缩到剩下的参数中。当前一般是使用字典或者元组作为第二个参数，但是很多人说这种办法缺乏弹性<sup>[3]</sup>.这种"要么全选，要没什么都没"的方法(意味着要么只选位置参数，要么只选关键字参数)让人感觉非常受限制。

这个提案和`string.Template`有部分重叠，但其实它们是针对不同的需求，选择了其中一个并不代表就排除另一个。这个提案的机制很像`%`，对于一个小的，只使用一次的字符串很有效。所以，将一个字符串编译为模板并不在这个提案的考虑范围。虽然这个提案精心设计的格式化字符串和API可以使一个Template模块很受启发。

### Specification(规范)

specification由以下几部分组成:

- 为当前的`str`类型加入一个格式化方法
- 将几个函数和flags加入到`string`模块，让底层的格式化引擎可以使用这些额外选项
- 一个新的格式化字符串语法
- 一组新的方法，可以控制对象的格式化和转换(conversion)
- 一个API，可以让用户继承并自定义
- 怎么处理格式化错误

注意字符串编码：讨论的这篇PEP处于Python3.0环境，所以它假定所有的字符串都是Unicode字符串，这篇文档中提到的"string"也是指代Python3的"string"，它和Python2的unicode对象一样。

在Python2环境下，这篇文档使用的单词"string"可以使常规字符串也可以是unicode。转换的结果也和输入时的字符串类型保持一致。

#### String Methods

内置`str`类型(Python2叫做unicode)将会获得一个新的方法,`format`，它可以接受任意数量的位置参数和关键字参数：

```python
"The story of {0}, {1}, and {c}".format(a, b, c=d)
```

在格式化字符串中，每个位置参数都以一个数字标识，从0开始。所以在上面例子中，'a'是参数0，'b'是参数1.每个关键字参数都以关键字名称来标识。所以在上面例子中，'c'用来引用第3个参数.

另外还有个全局内置函数，用于格式化单个值：

```python
print(format(10.0, "7.3g"))
```

这个函数会在之后的章节提到。

#### Format Strings

格式化字符串由字符数据(character data)和标记(markup)混合构成。

字符数据从格式化字符串到输出字符串中保持不变；标记不会直接从格式化字符串转移到输出，而是定义了“替换字段(replacement field)”，它会告诉格式化引擎标记位置应该放入什么。

大括号字符用来标明字符串中的“替换字段”：

```python
"My name is {0}".format('Fred')
```

这个字符串的结果为:

```python
"My name is Fred"
```

可以连续两个重复大括号来将它转义：

```python
"My name is {0} :- {{ }}".format('Fred')
```

将会生成:

```python
"My name is Fred :-{ }"
```

在大括号中的元素被称为"字段(field)".字段由"字段名(field name)"组成，字段名可以简单也可以混合(compound)，另外可以指定一个可选的"format specifier".

#### Simple and Compound Field Names

简单的字段名可以是数字或名称。如果是数字，比如是合法的10进制正式；如果是名称，必须是合法的Python标识符。数字用来代表位置参数，名称用来代表关键字参数。

混合字段(compound field)是指在一个表达式中组合了多个简单的字段名：

```python
"My name is {0.name}".format(open('out.txt', 'w'))
```

上面展示了一个在字段表达式中使用“getter”或"dot"操作符的例子。dot操作符可以允许输入值的属性作为字段的值。

不像其它的编程语言，你不能在格式化字符串中加入任意的表达式。这是一个刻意设计 - 你可以使用的表达式类型被故意限制。只支持两个操作符: `'.'(getter)`操作符，和
`'[]'(getitem)`操作符。允许这些操作的原因是它们不会逻辑代码产生副作用。

一个"getitem"语法的例子：

```python
"My name is {0[name]}".format(dict(name='Fred'))
```

你可能会注意到"getitem"在格式化字符串中的使用有些不同。在上面的例子中，字符串`name`应该加上引号，而不是现在这种变量形式。解析item key的规则很简单，如果
它以数字开头，则把它当作数字，否则就当作字符串。

因为key没有被强制使用引号，所以在格式化字符串中并不能指定任意的字典键(如字符串"10"，会被当作数字看待)。

实现注解：这个提案的实现并没有强制要求simple或者dotted的名称是一个Python标识符。而是当标识符不合法时，由底层的`getattr()`函数抛出异常。
`str.format()`函数有一个迷你解析器，只有当它的标识符结束时才会开始计算。

#### Format Specifiers

每个字段都可以设置一个可选组：`format specifiers`，它们可以用来调整字段的格式。`format specifier`在`field name`后面，以冒号`:`分隔：

```python
"My name is {0:8}".format('Fred')
```

格式说明符的语法含义根据对象类型而定，但是有一套标准的格式说明符可以用于任意对象。

格式说明符本身可以包含替换字段。例如一个字段的宽度可以通过参数指定:

```python
"{0:{1}}".format(a, b)
```

"里面"的替换字段可以出现在替换字段的格式化说明符部分。内部替换字段本身并不能继续再添加格式化说明符。也就是说替换字段并不能嵌套任意层级。

注意尾部两个重复的`}}`，一般来说它会被转义，但是在这个例子中不会。这是因为`{{` 和 `}}`的转义语法只应用于外部替换字段。在一个格式化字段中，大括号字符总是具有它们原始的含义。

格式化说明符是开放式的，因为子类可以覆盖标准格式化说明符。在这种情况下，`str.format()`方法仅将所有第一个冒号以后的字符传入底层的格式化方法就行了。

#### Standard Format Specifiers

如果一个对象没有定义它自己的格式化说明符，将会使用一组标准的格式化说明符。这组说明符和`%`插值方法很像，但是也还是有些区别的。

标准格式符说明符的一般形式为：

```python
[[fill]align[sign][#][0][minimunwidth][.precision][type]]
```

中括号`[]`代表这是一个可选元素。

然后可选的`align`标识可以选择下面中的一个：

- `<`

    强制让字段在可获取空间中向左对齐(这是默认的选择).

- `>`

    强制让字段在可获取空间中向右对齐.

- `=`

    强制让padding放在sign(如果存在)之后，但是在digits之前。这个对齐选项只对数值类型有效。打印的字段类似`'+000000120'`

- `^`

    强制让字段在可获取空间中居中对齐。

注意，除非指定了`minimumwidth`，否则字段的宽度总是和填充的数据一样，这个情况下面对齐选项没有用处。

选项`'fill'`字符定义了一个填充字符，置入到最小宽度的空白处。如果使用了填充字符，必须同时指定对齐标识。

`sign`选项只针对数值类型有效，可以是下面中的一种:

- `+`

    这个标识将会应用到正数和负数。

- `-`

    这个标识将会应用到负数.

- ` `

    这是一个空格，应用到正数。

如果使用了`#`字符，整数应该使用另一种格式化形式。这意味着二进制，八进制，十六进制的输出将会各自加上前缀`0b`, `0o`, `0x`.

`width`是一个小数整数，用来定义字段的最小宽度。如果没有指定，宽度将有内容来决定。

如果宽度字段前面是0，证明是0填充。等同于使用对齐格式`=`和填充字符`0`.

`precision`是一个小数，指在一个浮点数转换时在小数点后面显式几位。如果是整数转换，将会忽略这个`precision`.

最后，`type`决定数据应该以什么类型表示。

可用的整数表现类型包括：

- `b`

    二进制。

- `c`

    字符。在打印之前将整数转换成想用的Unicode字符。

- `d`

    小数整数。输出的数值是10进制。

- `o`

    八进制格式。

- `x`

    十六进制格式。大于9的数字以小写字母表示。

- `X`

    十六进制格式。大于9的数字以大写字母表示。

- `n`

    数字。它和`d`相同，除了它使用当前本地设置来插入适当的数字分隔字符。

- `' '(None)`

    和`d`相同。

可用的浮点数表现形式包括:

- `e`

    指数记号法。使用科学计数法打印数字，字符`e`表示指数。

- `E`

    指数记号法。和`e`相同，除了使用大写字母表示指数。

- `f`

    fixed point.

- `F`

    fixed point.和`f`相同，除了使用大写字母.

- `g`

    一般格式。一把将数字以`f`fixed-point格式打印，但是在数值过大时转换成`e`指数记号法。

- `G`

    和`g`相同，但是字母以大写形式表示。

- `n`

    数字。和`g`相同，除了它使用本地设置来插入合适的数字分隔字符。

- `%`

    百分比。将数字乘100并以`f`格式表示，然后加上一个百分比记号。

- `' '(None)`

    和`g`相同，除了它在小数点以后最少会打印一个数字。

对象可以定义自己的格式化标识符来代替标准的标识符。比如`datetime`类型，它的格式化标识符看起来和`strftime()`函数的参数很像：

```python
"Today is: {0:%a %b %d %H:%M:%S %Y}".format(datetime.now())
```

#### Explicit Conversion Flag(显式转换标识)

显式转换标识可以在一个值格式化之前将它变形。目前，有两个显式转换标识符：

- `!r`

    使用`repr()`将值转换为一个字符串。

- `!s`

    使用`str()`将值转换为一个字符串。

这个标识放在格式化标识符之前：

```python
"{0!r:20}".format("Hello")
```

打印上面的字符串：`"Hello"`。包含了引号，并且会保持最少20个字符宽度。

一个自定义的`Formatter`类可用定义更多的转换标识。但是如果内置的`formatter`如果碰到不认识的转换标识就会抛出`ValueError`.

#### Controlling Formatting on a Per-Type Basis(在每个类型的基础上控制格式化方式)

每个Python类型都可以通过定义`__format__`方法来控制它实例的格式化。`__format__`方法负责解释格式化标识符，将值格式化，最后返回最终结果字符串。

新加入的内置函数`format()`可以调用`(每个实例的)`这个特殊方法，就像`len()`和`str()`都可以调用它们各自的特殊方法一样：

```python
def format(value, format_spec):
    return value.__format__(format_spec)
```

可以为这个函数传入`None`(因为`None`在Python中是一个对象，可以拥有方法).

很多内置类型，包括`str`, `int`, `float`和`object`都定义了`__format__`方法。这意味着，如果你继承了这些类型，你的类将会知道如何格式化自己。

`object.__format__`方法是最简单的：它只是简单地将对象转换为一个字符串，然后再次调用`format`:

```python
class object:
    
    def __format__(self, format_spec):
        return format(str(self), format_spec)
```

`int`和`flot`的`__format__`方法将会根据格式化标识符来做一些数值格式化。在一些情况下，这些格式化操作可以被其它类型委派。例如，在`int`formatter看见`f`的时候，它会把值转换为浮点数并再次调用`format()`.

任何类都可以重写`__format__`方法，提供这个类型的自定义格式方式:

```python
class AST:
    
    def __format__(sef, format_spec):
        # ...
```

注意在Python2.x中，`format_spec`可能是一个`str`对象或者`unicode`对象。

注意，之前章节提到的**显式转换标识**不会被传入到`__format__`方法中。会在调用`__format__`方法之前就进行转换。

#### User-Defined Formatting

在每个类型基础上面定义`__format__`方法的时候仍不够要求时可以定义Format子类。比如电子表格应用，在值的长度太长，超过可用空间时它会使用hash符号`#`来代替。

对于更加强大和弹性的格式化，可以通过`string.Formatter`这个类来实现。它可以接受一些额外的选项，这些选项是`str.format()`没有的。

应用可以通过继承`Formatter`类来定义它自定义的格式化行为。

这份PEP并不会试图限制指定`Formatter`类的所有方法和属性；而是定义和描述一些初始实现(的方法和属性)。不过，这份PEP`Formatter`类的基本要求，在下面列出。

虽然`string.format()`并没有直接使用`Formatter`来格式化，但是使用了相同的底层实现。`string.format()`不直接使用`Fomatter`类的原因是`str`是一个内置类型，所以它的所有方法都是以C来实现的，而`Formatter`是一个Python类。`Formatter`提供了一个扩展方式，封装了`string.format()`使用的相同的C函数。

#### Formatter Methods

`Formatter`类不需要初始化参数：

```python
fmt = Formatter()
```

类`Formatter`的公共API方法如下：

- `format(format_string, *args, **kwargs)`

- `vformat(format_string, args, kwargs)`

`.format()`是主要的API方法。它接受一个格式化模版，以及任意数量的位置参数及关键字参数。`format()`是对`vformat()`的封装。

`vformat()`是一个函数，是它真正完成了格式化。它被暴露为一个独立函数，是因为怕你偏爱传入预先定义好的元组或字典参数，而不是使用*args,**kwargs语法将参数unpack.`vformat()`做的事情就是将格式化模版分割成字符数据和待替换字段。它们分别叫做`get_positional()`和`get_index()`方法。

`Formatter`定义了如下这些可供覆盖的方法：

- `get_value(key, args, kwargs)`
- `check_unused_args(used_args, args, kwargs)`
- `format_field(value, format_spec)`

pass