# asyncio -- Asynchronous I/O, event loop, and concurrency tools

*用途:一个异步I/O和并发框架*

`asyncio`模块可以让你使用协程来编写并发应用。`threading`使用应用线程(application threads)来实现并发，`multiprocessing`使用系统进程来实现并发，`asyncio`使用单线程、单进程的方式，不过在任务等候I/O的时候可以切换到其它任务的执行。大多数时候，上下文转换在程序等待读取/写入的堵塞时间发生，不过`asyncio`可以规划代码，让它在一个预定时间运行，让一个协程等待另一个协程完成，或者处理系统信号，或者识别一些事件的发送。

## Asynchronous Concurrency Concepts

多数程序写的并发模型都是线性的，依靠底层的线程/进程管理，在适当的时候切换上下文。基于`asyncio`的应用要求应用代码显式的处理上下文改动。

`asyncio`提供的框架紧紧围绕一个概念 -- 事件循环(event loop)，这个对象负责高效的处理I/O事件，系统事件和应用上下文改动。根据操作系统，提供了若干种不同的事件循环实现。

应用和事件循环的交互是为了代码执行显式的进行注册，资源可用时事件循环进行调用。例如，一个网络服务器开启sockets，然后注册这些sockets，在输入事件出现时告诉它。事件循环在建立新的网络连接或数据读取时通知服务器。应用代码会在I/O堵塞时交出控制权。例如，如果暂时socket没有数据可以读取，服务器应该将控制权交回给事件循环。

这个**把控制权交回给事件循环**的机制是依靠Python的协程来实现的，这是一种特殊的函数，可以将控制权暂时放弃但是不会丢失当前的状态。协程和生成器函数类似，事实上在Python3.5没有原生协程之前，就是使用生成器函数来实现协程的。`asyncio`同样提供了类级别的抽象层，可以编写回调式的异步代码。

`Future`是一种数据结构，代表一个数据的结果还没有完成。事件循环可以观察`Future`对象是否完成，允许应用的一部分代码等待另一部分代码完成。除了`Future`，`asyncio`包含另外一些并发原语，包括locks, semaphores.

`Task`是`Future`是一个子类，它知道如何封装和管理一个协程的执行。Task可以被事件循环规划执行，可以生成一个结果供其它协程使用。