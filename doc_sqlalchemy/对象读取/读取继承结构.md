[TOC]

## 读取继承结构

使用`joined`, `single`, `concrete`表继承方法来实现继承结构时，通常的行为是对一个特定基类的查询将同样会生成子类对象。当单个查询能够针对一个结果行(row)返回的结果有不同的类，我们把它称为**多态读取**。

对于**多态读取**来说，指定joined和single表继承时，另一个问题是将会首先查询哪个子类属性，随后查询哪个子类属性。当一个特定子类的属性被首先查询时，我们可以将它进一步筛选。对于稍晚查询的子类属性，会在我们首次访问它时才会读取。对这个行为的基础控制可以使用函数`orm.with_polymorphic()`，以及两个变体，映射配置可以`mapper.with_polymorphic`可以结合`mapper.polymorphic_load`选项，以及查询(Query)级别的配置的方法`Query.with_polymorphic()`。

### 使用with_polymorphic

对于以下的章节，假定使用`Employee/Enginner/Manager`例子。

一般来说，当一个`Query`指定一个继承结构的基类，只有位于这个基类中的column将会被查询：

`session.query(Employee).all()`

上面的例子中，对于joined和single表继承方式，只有位于`Employee`中的列会出现在SELECT中。我们可能获取`Engineer`或者`Manager`的实例，然而这个属性是惰性读取。

同样的，如果我们想要在这个查询中引用`Engineer`或者`Manager`中的列，这些列不能直接在joined或者single继承方式中直接获取，因为`Employee`实体没有引用这些列。

想要解决这些问题，`orm.with_polymorphic()`函数提供了一个特殊的`AliasedClass`，它代表子类中列Column的范围。这个对象可以用在`Query`中当作一般的的alias一样：

```python
from sqlalchemy.orm import with_polymorphic

eng_plus_manager = with_polymorphic(Employee, [Engineer, Manager])

query = session.query(eng_plus_manager)
```

如果上面的映射使用了joined表继承，上面的SELECT语句将会类似下面这样：

```python
query.all()

SELECT employee.id AS employee_id,
    engineer.id AS engineer_id,
    manager.id AS manager_id,
    employee.name AS employee_name,
    employee.type AS employee_type,
    engineer.engineer_info AS engineer_engineer_info,
    manager.manager_data AS manager_manager_data
FROM employee
    LEFT OUTER JOIN enginner
        ON employee.id = engineer.id
    LEFT OUTER JOIN manager
        ON employee.id = manager.id

[]
```

上面SQL语句中，"engineer"和"manager"中额外的表和列都会被加入进来。在single继承方式中也会是同样的行为。

`orm.with_polymorphic()`接收单个类或者映射，类和映射的列表，或者可以使用通配符`'*'`来指向所有子类：

```pyhton
# 包含Engineer的列
entity = with_polymorhpic(Employee, Engineer)

# 包含Engineer和Manager的列
entity = with_polymorphic(Employee, [Engineer, Manager])

# 包含所有映射子类的列
entity = with_polymorphic(Employee, '*')
```

#### 在with_polymorphic中使用aliasing

