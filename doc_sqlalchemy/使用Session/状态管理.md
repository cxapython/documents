## 对象状态的快速入门

明白实例在session中的状态会很有帮助：

- `Transient`: 一个不在session中的实例，并且没有被保存到数据库。也就是说它没有数据库实体。

- `Pending`: 当你吧一个pending实例使用`add()`加入到session中。它还没有真正的刷新到数据库，
            但是在下一次刷新时被保存到数据库。
            
- `Persistent`: 一个在session中并且在数据库中有记录的实例。你可以通过刷新来获得持久化
            实例，或者通过查询数据库来获得(或者把其它session的持久化实例移到当前session)
            
- `Deleted`: 一个在下次刷新时会被删除的实例，但是事务还没有提交。这个状态的对象是“pending”
            状态的反面;当事务提交后，这个对象会移到`detached`状态。另外，如果事务回滚，这个对象
            将会回归"persistent"状态。
            
- `Detached`: 一个对象对应（或之前对应)一条数据库记录，但是现在不存在于session中。
            `detached`对象将会包含数据库实体标记，但是因为它并不关联任何
            session，所以它不知道这个数据库实体是否存在与数据库中。`Detached`对象
            一般可以正常使用，除了不能使用它未读取的属性或者属性已经过期。
            
想要尽可能深入了解状态的过渡，请看`Object Lifestyle Events`描述了每个状态的过渡以及如何
追逐利用它们。

### 获取一个对象的当前状态

任何时候任何映射的对象的状态都可以通过`inspect()`系统获取：

```python
>>> from sqlalchemy import inspect
>>> insp = inspect(my_object)
>>> insp.persistent
True
```

## Session属性

Session本身扮演一个类set的集合容器。所有存在于其中的对象都可以通过迭代器接口获取：

```python
for obj in session:
    print(obj)
```

并且可以通过"contains"语法来测试对象是否存在于该session:

```python
if obj in session:
    print("Object in present")
```

session同样会追踪所有新创建(pending状态)对象，以及所有在上次读取或保存后
有变化的(也就是变“脏(dirty)”了)对象，以及所有被标记为删除的对象。

```pyhton
# 最近加入到session的pending对象
session.new

# 持久化对象但是检测到当前有所变动
# (这个集合(属性)每次调用时创建
session.dirty

# 持久化对象被标记为删除(通过session.delete()方法)
session.deleted

# 所有持久化的对象，以字典形式出现，以它们的标识符作为键
session.identity_map
```

## Session引用行为

session中的对象都是弱引用．这意味着如果在app外面将它解除引用的话，session中的对应
对象也会被Python解释器给垃圾回收．例外的情况包含对象为pending状态,deleted状态，
或者持久化对象因为被修改转为pending状态．在一次刷新后，这些集合(dirty, new...等等)
都会清空，所有的对象又变为弱引用．

想要session中的对象保持强引用，通常需要使用一个简单的办法．比如把读取的对象包含到一个
字典中，或者包括到一个列表或ｓｅｔ中，那么它们就会被保持引用．这些集合可以使用`session.info`
字典来关联到一个Session中．

一个事件基础的例子也是可行的．一个为所有对象保持强引用的例子如下：

```python
from sqlalchemy import event


def strong_reference_session(session):
    @event.listens_for(session, "pending_to_persistent")
    @event.listens_for(session, "deleted_to_persistent")
    @event.listens_for(session, "detached_to_persistent")
    @event.listens_for(session, "loaded_as_persistent")
    def strong_ref_object(sess, instance):
        if "refs" not in sess.info:
            sess.info['refs'] = refs = set()
        else:
            refs = sess.info['refs']
        
        sess.add(instance)
        
    
    @event.listens_for(session, "persistent_to_detached")
    @event.listens_for(session, "persistent_to_deleted")
    @event.listens_for(session, "persistent_to_transient")
    def derefs_object(sess, instance):
        sess.info['refs'].discard(instance)
```

上面例子中，我们拦截了`SessionEvents.pending_to_persistent(), SessionEvents.detached_to_persistent()`, 
`SessionEvents.deleted_to_persistent()和SessionEvents.loaded_as_persistent()`
事件钩子来为对象进入persistent状态时设置一个时间．设置了`SessionEvents.persistent_to_detached()`
和`SessionEvents.persistent_to_deleted()`来为离开persistent状态的对象设置事件．

上面的函数应该对每个要使用的`Session`实例都调用一次，用来获得强引用行为:

```python
from sqlalchemy.orm import Session

my_session = Session()
strong_reference_session(my_session)
``` 

也可以对`sessionmaker()`生成的对象调用(全局配置):

```python
from sqlalchemy.orm import sessionmaker

maker = sessionmaker()
strong_reference_session(maker)
```

## 合并

`merge()`把一个session外对象的状态转移到session中，它同样会调停当前数据的数据库状态，
生成一个历史流，在下次刷新时使用．用法如下:

`merged_object = session.merge(existing_object)`

当传入一个实例时，它会运行如下步骤：

- 它会检查实例的主键．如果发现存在，它会把这个实例放在本地的identity map．默认设置了
    `load=True`，如果主键在本地不存在则会检查数据库．
    
- 如果给定的实例没有主键，或者给定的主键没有想匹配的实例，将会创建一个新实例．

- 然后给定实例的状态将会拷贝到新创建的实例中．对于在源实例中出现的属性，这些值都会转移到
    目标实例中．对于不存在于源的映射属性，目标实例中的属性会过期，丢弃现存的值．
    
- 这个操作级联相关对象和集合，这个级联指的是`merge`

- 返回新的实例．

对于`merge()`来说，源实例不会被修改也不关联它的目标Session．可以继续让它合并到其它任意
数量的Session对象中．`merge()`有用的地方是它可以拿任何类型数据结构的状态复制到新的session
中．下面是一些例子：

- 一个应用读取文件中的一个对象结构，将它从文件中解析出来，创建数据结构，然后使用`merge()`
    存入数据库，确保文件中的数据以每个结构的主键来形成．之后，如果文件有所感动，同样的
    进程会再次运行，生成一个稍微不同的对象结构，可以对它再次使用`merge()`,然后`Session`
    会自动更新数据库来映射这些变动：通过主键从数据库读取每个对象然后通过新的状态更新它的状态．
    
- 一个应用把对象存在一个内存缓存中，同时共享给多个`Session`对象．`merge()`做的工作就是
    每次请求时从缓存中取回值然后在创建一个本地拷贝．缓存对象保持detached；只有它的状态被拷贝．
    
    在这个缓存的例子中，通常使用`load=False`来去掉和数据库协调的开销．还有一个批量版本的
    `merge()`，叫做`merge_result()`，设计与用来实现缓存扩展的`Query`对象．
    
- 一个应用想要转移一个工作线程维持的一系列对象到Session中．`merge()`将对被个对象创建一个
    拷贝并放入新的Session中．在这个操作结束的时候，父进程/线程将会继续维持它开始维持的对象．
    
    在这个例子中，推荐设置`load=False`来取消多余的SQL查询．
    
### 合并tips

`merge()`在很多场合都很有用.它处理transient/detached状态和persistent状态之间，以及状态的自动转移之间的复杂对象。这些情况通常要求对对象的状态使用更加小心的方法.常见的合并问题是传入对象的状态出乎意料。

让我们使用最开始的User/Address模型：

```python
class User(Base):
    __tablename__ = 'user'

    id = Column(Integer, primary_key=True)
    name = Column(String(50), nullable=False)
    addresses = relationship("Address", backref="user")


class Address(Base):
    __tablename__ = 'address'

    id = Column(Integer, primary_key=True)
    email_address = Column(String(50), nullable=False)
    user_id = Column(Integer, ForeignKey('user.id'), nullable=False)
```

假定一个User对象具有一个Address,并且已经持久化了：

```python
>>> u1 = User(name='ed', addresses=[Address(email_address="ed%ed.com")])
>>> session.add(u1)
>>> session.commit()
```

现在我们创建一个`a1`,一个session外面的对象,我们想要将它合并到存在的Address对象：

```python
>>> existing_a1 = u1.addresses[0]
>>> a1 = Address(id=existing_a1.id)
```

如果我们直接使用`merge()`，将会发生惊喜：

```python
>>> a1.user = u1
>>> a1 = session.merge(a1)
>>> session.commit()
sqlalchemy.orm.exc.FlushError: New instance <Address at 0x1298f50>
with identity key (<class '__main__.Address'>, (1,)) conflicts with
persistent instance <Address at 0x12a25d0>
```

为什么会这样?因为我们没有小心处理级联.`a1.user`的引用是`User.addresses`的反引用,将会是我们的a1对象pending,即使我们添加了它.现在我们在session中有了两个Address对象：

```python
>>> a1 = Address()
>>> a1.user = u1
>>> a1 in session
True
>>> existing_a1 in session
True
>>> a1 is existing_a1
False
```

上面例子中，`a1`在session中已经是pending状态。随后的`merge()`其实什么也没做。

级联可以在`relationship()`中设置，比如设置`cascade_backres=False`。

另一个意料之外状态的例子是：

```python
>>> a1 = Address(id=existing_a1.id, user_id=u1.id)
>>> assert a1.user is None
True
>>> a1 = session.merge(a1)
>>> session.commit()
sqlalchemy.exc.IntegrityError: (IntegrityError) address.user_id
may not be NULL
```

上面，我们访问`a1.user`，返回了默认的值`None`，它是这次访问的记过，存储在对象`a1`的`__dict__`中。一般情况下，这个创建不会触发事件,所以`user_id`属性要在刷新时才会生效.但是当我们把Address对象合并进入到session，这个操作等同于：

```python
>>> existing_a1.id = existing_a1.id
>>> existing_a1.user_id= u1.id
>>> existing_a1.user = None
```

多数`merge()`问题都可以很快发现 - 这个对象是否过早的存在于session?

```python
>>> a1 = Address(id=existing_a1, user_id=user.id)
>>> assert a1 not in session
>>> a1 = session.merge(a1)
```

获取对象中有我们不期望的状态？检查`__dict__`:

```python
>>> a1 = Address(id=existing_a1, user_id=user_id)
>>> a1.user
>>> a1.__dict__
{'_sa_instance_state': <sqlalchemy.orm.state.InstanceState object at 0x1298d10>,
    'user_id': 1,
    'id': 1,
    'user': None}
>>> # 我们不想把 user=None 合并,移除它。
>>> del a1.user
>>> a1 = session.merge(a1)
>>> # 成功
>>> session.commit()
```

## 清除(expunge)

expunge会把一个对象从Session中移除,让persistent实例变为detached状态，让pending实例变为transient状态:

`session.expunge(obj1)`

想要移除所有的项，调用`expunge_all()`（这个方法之前叫做`clear()`).

## 刷新/过期

**过期**意味着数据库维持的数据包含的一系列属性都被抹除,在这种情况下如果重新访问这些属性,将会发出一个SQL从数据库取回刷新数据。

当我们谈论数据过期时,我们通常讨论的是一个处于persistent状态的对象.例如,如果我们读取的对象像下面这样：

```python

```