## 对象状态的快速入门

明白实例在session中的状态会很有帮助：

- `Transient`: 一个不在session中的实例，并且没有被保存到数据库。也就是说它没有数据库实体。

- `Pending`: 当你吧一个pending实例使用`add()`加入到session中。它还没有真正的刷新到数据库，
            但是在下一次刷新时被保存到数据库。
            
- `Persistent`: 一个在session中并且在数据库中有记录的实例。你可以通过刷新来获得持久化
            实例，或者通过查询数据库来获得(或者把其它session的持久化实例移到当前session)
            
- `Deleted`: 一个在下次刷新时会被删除的实例，但是事务还没有提交。这个状态的对象是“pending”
            状态的反面;当事务提交后，这个对象会移到`detached`状态。另外，如果事务回滚，这个对象
            将会回归"persistent"状态。
            
- `Detached`: 一个对象对应（或之前对应)一条数据库记录，但是现在不存在于session中。
            `detached`对象将会包含数据库实体标记，但是因为它并不关联任何
            session，所以它不知道这个数据库实体是否存在与数据库中。`Detached`对象
            一般可以正常使用，除了不能使用它未读取的属性或者属性已经过期。
            
想要尽可能深入了解状态的过渡，请看`Object Lifestyle Events`描述了每个状态的过渡以及如何
追逐利用它们。

### 获取一个对象的当前状态

任何时候任何映射的对象的状态都可以通过`inspect()`系统获取：

```python
>>> from sqlalchemy import inspect
>>> insp = inspect(my_object)
>>> insp.persistent
True
```

## Session属性

Session本身扮演一个类set的集合容器。所有存在于其中的对象都可以通过迭代器接口获取：

```python
for obj in session:
    print(obj)
```

并且可以通过"contains"语法来测试对象是否存在于该session:

```python
if obj in session:
    print("Object in present")
```

session同样会追踪所有新创建(pending状态)对象，以及所有在上次读取或保存后
有变化的(也就是变“脏(dirty)”了)对象，以及所有被标记为删除的对象。

```pyhton
# 最近加入到session的pending对象
session.new

# 持久化对象但是检测到当前有所变动
# (这个集合(属性)每次调用时创建
session.dirty

# 持久化对象被标记为删除(通过session.delete()方法)
session.deleted

# 所有持久化的对象，以字典形式出现，以它们的标识符作为键
session.identity_map
```

## Session引用行为

session中的对象都是弱引用．这意味着如果在app外面将它解除引用的话，session中的对应
对象也会被Python解释器给垃圾回收．例外的情况包含对象为pending状态,deleted状态，
或者持久化对象因为被修改转为pending状态．在一次刷新后，这些集合(dirty, new...等等)
都会清空，所有的对象又变为弱引用．

想要session中的对象保持强引用，通常需要使用一个简单的办法．比如把读取的对象包含到一个
字典中，或者包括到一个列表或ｓｅｔ中，那么它们就会被保持引用．这些集合可以使用`session.info`
字典来关联到一个Session中．

一个事件基础的例子也是可行的．一个为所有对象保持强引用的例子如下：

```python
from sqlalchemy import event


def strong_reference_session(session):
    @event.listens_for(session, "pending_to_persistent")
    @event.listens_for(session, "deleted_to_persistent")
    @event.listens_for(session, "detached_to_persistent")
    @event.listens_for(session, "loaded_as_persistent")
    def strong_ref_object(sess, instance):
        if "refs" not in sess.info:
            sess.info['refs'] = refs = set()
        else:
            refs = sess.info['refs']
        
        sess.add(instance)
        
    
    @event.listens_for(session, "persistent_to_detached")
    @event.listens_for(session, "persistent_to_deleted")
    @event.listens_for(session, "persistent_to_transient")
    def derefs_object(sess, instance):
        sess.info['refs'].discard(instance)
```

上面例子中，我们拦截了`SessionEvents.pending_to_persistent(), SessionEvents.detached_to_persistent()`, 
`SessionEvents.deleted_to_persistent()和SessionEvents.loaded_as_persistent()`
事件钩子来为对象进入persistent状态时设置一个时间．设置了`SessionEvents.persistent_to_detached()`
和`SessionEvents.persistent_to_deleted()`来为离开persistent状态的对象设置事件．

上面的函数应该对每个要使用的`Session`实例都调用一次，用来获得强引用行为:

```python
from sqlalchemy.orm import Session

my_session = Session()
strong_reference_session(my_session)
``` 

也可以对`sessionmaker()`生成的对象调用(全局配置):

```python
from sqlalchemy.orm import sessionmaker

maker = sessionmaker()
strong_reference_session(maker)
```

## 合并